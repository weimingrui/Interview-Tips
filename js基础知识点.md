## 1. 原始数据类型、复杂数据类型，他们的存储方式及内存释放
原始数据类型： **string number boolean null undefined symbol**
复杂数据类型： **array object set weakset map weakmap function Date等**

**原始数据类型存储在栈内存；**
**复杂数据类型存储在堆内存，指向他实例的引用地址数据存储在栈内存。**

### 栈内存清理：
JavaScript 引擎通过向下移动 ESP 指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。

###  堆内存清理： 
代际假说特点：
    - 大部分对象存活时间很短
    - 不被销毁的对象，会活的更久

V8 中会把堆分为 **新生代** 和 **老生代** 两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。
**新生区的容量没有老生区那么大**，所以 V8 分别使用 2 个不同的垃圾回收器，来高效实施垃圾回收：

**副垃圾回收器**：主要负责新生代的垃圾回收。
**主垃圾回收器**：主要负责老生代的垃圾回收。

新生代 - 副垃圾回收器
    Scavenge 算法
    **把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域.**
    新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
    先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中
    完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。
    对象晋升策略：**经过两次垃圾回收依然还存活的对象，会被移动到老生区中。**

老生代 - 主垃圾回收器
    算法：标记 - 清除（Mark-Sweep）算法
    原理：
        标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
        清除：将垃圾数据进行清除。
    对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。
    算法：标记 - 整理（Mark-Compact）算法
    原理：
        标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。
        整理：让所有存活的对象都向内存的一端移动
        清除：清理掉端边界以外的内存

全停顿
    由于 JavaScript 是单线程的，所以一旦执行垃圾回收算法，那正在执行的 JavaScript 脚本需要暂停下来，等垃圾回收完毕之后再恢复脚本执行。这种行为叫 全停顿（Stop-The-World）。
    优化算法：**增量标记（Incremental Marking）算法**
    原理：
        为了降低老生代的垃圾回收而造成的卡顿
        V8 把一个完整的垃圾回收任务拆分为很多小的任务
        让垃圾回收标记和 JavaScript 应用逻辑交替进行

## 2 执行上下文、执行栈

    全局执行上下文：这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
    函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。
    Eval 函数执行上下文：执行在 eval 函数内部的代码也会有它属于自己的执行上下文。

    执行栈，也就是在其它编程语言中所说的 “调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。
## 3 函数式编程特点、纯函数
    1. 函数是一等公民。可以利用这点让它支持抽取到外部。
    声明做某件时间。函数式编程大多数声明某个函数需要做什么，而不是它怎么做的。
    2. 便于垃圾回收。函数内部的变量方便垃圾回收，不会产生太多的变量，用户不需要大量的定义。
    3. 数据不可变。函数式编程要求所有的数据都是不可变的，如果需要修改某个对象，应该新建后再修改，而不是污染原本的数据。
    4. 无状态。不管什么时候运行，同一个函数对相同的输入返回相同的输出，而不依赖外部状态的变化。
    4. 无副作用。功能 A 应该仅仅为了完成它的实现，而不会随着外部的改变而改变，这样当它执行完毕之后，就可以将其内部数据进行回收。并且它不会修改传入的参数。

    纯函数的概念有 2 点：
        不依赖外部状态（无状态）：函数的运行结果不依赖全局变量，this 指针，IO 操作等。
        没有副作用（数据不变）：不修改全局变量，不修改入参。
## 4 规范化
CommonJS 规范、AMD 规范、CMD 规范、ES6 Modules 规范

CommonJS为JavaScript提供了一种标准化的模块化解决方案，使得代码的组织和管理更加高效和便捷
AMD，全称Asynchronous Module Definition，即异步模块定义，是RequireJS在推广过程中对模块定义的规范化产出。
CMD 则是依赖就近，用的时候再 require
ES6 Modules 规范es6提出，用于在JavaScript中实现代码的模块化

ES6 Modules 和 CommonJS 区别：

CommonJS 模块是运行时加载，ES6 Modules 是编译时输出接口
CommonJS 输出是值的拷贝；ES6 Modules 输出的是值的引用，被输出模块的内部的改变会影响引用的改变
CommonJs 导入的模块路径可以是一个表达式，因为它使用的是require() 方法；而 ES6 Modules 只能是字符串
CommonJS this 指向当前模块，ES6 Modules 的 this 指向 undefined
ES6 Modules 中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname
## 5. babel 编译原理
    babylon 将 ES6/ES7 代码解析成 AST
    babel-traverse 对 AST 进行遍历转译，得到新的 AST
    新 AST 通过 babel-generator 转换成 ES5

## 6. 原型、原型链、数据类型判断

instanceof 
typeof
Object.prototype.toString.call()


## 7. new 操作符做了哪些操作

## 8.Event Loop

## 9.DOM 的创建 获取 添加 删除
createElement getElementById appendChild removeChild
dom.nextSibling dom.prevouseSibling
fisrtChild lastChild chriden

DOM 事件分为两个阶段，事件捕获和事件冒泡阶段
事件冒泡：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发（当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了 click 事件就触发父元素的 click）。
事件捕获：和冒泡相反，会从上层传递到下层。

addEventListener

dom.focus()
dome.click()
onmouseenter onmouseover
event.stopPropagation();
event.preventDefault();

## 暂时性死区，定时器等
requestAnimationFrame setTimeout setInterval
